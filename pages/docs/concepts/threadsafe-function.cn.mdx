---
title: 线程安全函数 - ThreadsafeFunction
description: 在其他线程中调用JavaScript回调。
---

# 线程安全函数 - ThreadsafeFunction

[`线程安全函数`](https://nodejs.org/api/n-api.html#asynchronous-thread-safe-function-calls) 在 Node.js 中是一个复杂的概念. 众所周知, Node.js 是单线程的, 所以你不能在另一个线程上访问 [`napi_env`](https://nodejs.org/api/n-api.html#napi_env), [`napi_value`](https://nodejs.org/api/n-api.html#napi_value), and [`napi_ref`](https://nodejs.org/api/n-api.html#napi_ref).

import { Callout } from 'nextra-theme-docs'

<Callout>
  [`napi_env`](https://nodejs.org/api/n-api.html#napi_env),
  [`napi_value`](https://nodejs.org/api/n-api.html#napi_value), 和
  [`napi_ref`](https://nodejs.org/api/n-api.html#napi_ref)
  是`Node-API`中一个低层次的概念, **NAPI-RS** 的`#[napi]`宏是建立在 `Node-API`
  之上的。 **NAPI-RS** 也提供了一个低级API来访问原来的`Node-API`。
</Callout>

`Node-API` 提供了复杂的 `Threadsafe Function` api 来调用其他线程上的 JavaScript 函数。它非常复杂，因此许多开发人员不知道如何正确使用它。**NAPI-RS** 提供了一个轻量版的 `Threadsafe Function` api，以使其更易于使用:

```rust {10} filename="lib.rs"
use std::thread;

use napi::{
  bindgen_prelude::*,
  threadsafe_function::{ErrorStrategy, ThreadsafeFunction, ThreadsafeFunctionCallMode},
};

#[napi]
pub fn call_threadsafe_function(callback: JsFunction) -> Result<()> {
  let tsfn: ThreadsafeFunction<u32, ErrorStrategy::CalleeHandled> = callback
    .create_threadsafe_function(0, |ctx| {
      ctx.env.create_uint32(ctx.value + 1).map(|v| vec![v])
    })?;
  for n in 0..100 {
    let tsfn = tsfn.clone();
    thread::spawn(move || {
      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);
    });
  }
  Ok(())
}
```

⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️

```ts filename="index.d.ts"
export function callThreadsafeFunction(callback: (...args: any[]) => any): void
```

`ThreadsafeFunction` 非常复杂，所以 **NAPI-RS** 没有提供它的精确的 TypeScript 定义生成。如果你想要一个更好的 TypeScript 类型，你可以使用 `#[napi(ts_args_type)]` 来覆盖 `JsFunction` 参数的类型:

```rust {8} filename="lib.rs"
use std::thread;

use napi::{
  bindgen_prelude::*,
  threadsafe_function::{ErrorStrategy, ThreadsafeFunction, ThreadsafeFunctionCallMode},
};

#[napi(ts_args_type = "callback: (err: null | Error, result: number) => void")]
pub fn call_threadsafe_function(callback: JsFunction) -> Result<()> {
  let tsfn: ThreadsafeFunction<u32, ErrorStrategy::CalleeHandled> = callback
    .create_threadsafe_function(0, |ctx| {
      ctx.env.create_uint32(ctx.value + 1).map(|v| vec![v])
    })?;
  for n in 0..100 {
    let tsfn = tsfn.clone();
    thread::spawn(move || {
      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);
    });
  }
  Ok(())
}
```

⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️

```ts filename="index.d.ts"
export function callThreadsafeFunction(
  callback: (err: null | Error, result: number) => void,
): void
```

## 错误处理策略 - ErrorStrategy

`Threadsafe Function` 有两种不同的错误处理策略。该策略可以在 `ThreadsafeFunction` 的第二个泛型参数中定义:

```rust filename="lib.rs"
let tsfn: ThreadsafeFunction<u32, ErrorStrategy::CalleeHandled> = ...

```

泛型形参中的第一个参数当然是`Threadsafe Function`的返回类型。

### `ErrorStrategy::CalleeHandled`

Rust 代码中的`Err`将被传递到 JavaScript 回调的第一个参数中。此行为遵循来自 Node.js 的异步回调约定: https://nodejs.org/en/knowledge/errors/what-are-the-error-conventions/ 。

Node.js 中的许多异步 api 都是这样设计的，比如 `fs.read`。

对于`ErrorStrategy::CalleeHandled`，你必须用 `Result` 类型调用 `ThreadsafeFunction` ，这样 `Error` 将被处理并传递回 JavaScript 回调:

```rust {17} filename="lib.rs"
use std::thread;

use napi::{
  bindgen_prelude::*,
  threadsafe_function::{ErrorStrategy, ThreadsafeFunction, ThreadsafeFunctionCallMode},
};

#[napi(ts_args_type = "callback: (err: null | Error, result: number) => void")]
pub fn call_threadsafe_function(callback: JsFunction) -> Result<()> {
  let tsfn: ThreadsafeFunction<u32, ErrorStrategy::CalleeHandled> = callback
    .create_threadsafe_function(0, |ctx| {
      ctx.env.create_uint32(ctx.value + 1).map(|v| vec![v])
    })?;
  for n in 0..100 {
    let tsfn = tsfn.clone();
    thread::spawn(move || {
      tsfn.call(Ok(n), ThreadsafeFunctionCallMode::Blocking);
    });
  }
  Ok(())
}

```

### `ErrorStrategy::Fatal`

如果你的代码永远不会返回`Err`，你可以使用这个策略来避免在 Rust 端使用`Ok`包装。这样将没有 `Error`会被传递回 JavaScript 端。

使用这种策略， `ThreadsafeFunction` 不需要用 `Result<T>` 调用，JavaScript 回调的第一个参数是来自 Rust 的值，而不是 `Error | null`。

```rust {17} filename="lib.rs"
use std::thread;

use napi::{
  bindgen_prelude::*,
  threadsafe_function::{ErrorStrategy, ThreadsafeFunction, ThreadsafeFunctionCallMode},
};

#[napi(ts_args_type = "callback: (result: number) => void")]
pub fn call_threadsafe_function(callback: JsFunction) -> Result<()> {
  let tsfn: ThreadsafeFunction<u32, ErrorStrategy::Fatal> = callback
    .create_threadsafe_function(0, |ctx| {
      ctx.env.create_uint32(ctx.value + 1).map(|v| vec![v])
    })?;
  for n in 0..100 {
    let tsfn = tsfn.clone();
    thread::spawn(move || {
      tsfn.call(n, ThreadsafeFunctionCallMode::Blocking);
    });
  }
  Ok(())
}

```

⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️

```ts {2} filename="index.d.ts"
export function callThreadsafeFunction(callback: (result: number) => void): void
```
